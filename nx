import cv2
import numpy as np
import matplotlib.pyplot as plt
import math

# -------- Grayscale Conversion using OpenCV --------
def to_grayscale(path):
    img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
    return img

# -------- Padding to Match Sizes --------
def pad_images(img1, img2):
    h1, w1 = img1.shape
    h2, w2 = img2.shape
    H, W = max(h1, h2), max(w1, w2)

    padded1 = np.zeros((H, W), dtype=np.uint8)
    padded2 = np.zeros((H, W), dtype=np.uint8)

    padded1[:h1, :w1] = img1
    padded2[:h2, :w2] = img2

    return padded1, padded2

# -------- Arithmetic & Logical Ops --------
def img_and(img1, img2): 
    print("AND Operation: Keeps pixels where BOTH images have high values (bitwise AND)")
    return np.bitwise_and(img1, img2)

def img_or(img1, img2): 
    print("OR Operation: Keeps pixels where EITHER image has high values (bitwise OR)")
    return np.bitwise_or(img1, img2)

def img_xor(img1, img2): 
    print("XOR Operation: Highlights differences between images (bitwise XOR)")
    return np.bitwise_xor(img1, img2)

def img_add(img1, img2): 
    print("ADD Operation: Brightens image by adding pixel values (increases brightness)")
    return np.clip(img1 + img2, 0, 255).astype(np.uint8)

def img_sub(img1, img2): 
    print("SUBTRACT Operation: Darkens image by subtracting pixel values (decreases brightness)")
    return np.clip(img1 - img2, 0, 255).astype(np.uint8)

def img_mul(img1, img2): 
    print("MULTIPLY Operation: Creates darker image, highlights common bright areas")
    return np.clip((img1 * img2) / 255, 0, 255).astype(np.uint8)

def img_div(img1, img2):
    print("DIVIDE Operation: Creates brighter image, highlights areas where img1 > img2")
    img2 = np.where(img2 == 0, 1, img2)  # avoid divide by zero
    return np.clip((img1 / img2) * 255, 0, 255).astype(np.uint8)

# -------- Gray Level Transformations --------
def linear_transform(img, a=1.0, b=0):
    """Linear transformation: s = a*r + b"""
    print(f"Linear Transform: s = {a}*r + {b} (adjusts contrast and brightness)")
    result = np.zeros_like(img, dtype=float)
    h, w = img.shape
    for i in range(h):
        for j in range(w):
            result[i, j] = a * img[i, j] + b
    return np.clip(result, 0, 255).astype(np.uint8)

def log_transform(img, c=1.0):
    """Log transformation: s = c * log(1 + r)"""
    print(f"Log Transform: s = {c} * log(1 + r) (expands dark regions, compresses bright)")
    result = np.zeros_like(img, dtype=float)
    h, w = img.shape
    for i in range(h):
        for j in range(w):
            # Ensure we don't get negative values and handle overflow
            pixel_val = abs(float(img[i, j]))  # Convert to float and ensure positive
            log_val = math.log(1.0 + pixel_val)
            result[i, j] = c * log_val
    return np.clip(result, 0, 255).astype(np.uint8)

def power_law_transform(img, c=1.0, gamma=1.0):
    """Power law transformation: s = c * (r^gamma)"""
    print(f"Power Law Transform: s = {c} * (r^{gamma}) (gamma<1 brightens, gamma>1 darkens)")
    result = np.zeros_like(img, dtype=float)
    h, w = img.shape
    for i in range(h):
        for j in range(w):
            normalized = img[i, j] / 255.0
            result[i, j] = c * (normalized ** gamma) * 255
    return np.clip(result, 0, 255).astype(np.uint8)

# -------- Thresholding --------
def binary_threshold(img, thresh=127):
    """Simple binary thresholding"""
    print(f"Binary Threshold: Pixels > {thresh} become 255, others become 0")
    result = np.zeros_like(img)
    h, w = img.shape
    for i in range(h):
        for j in range(w):
            if img[i, j] > thresh:
                result[i, j] = 255
            else:
                result[i, j] = 0
    return result

def otsu_threshold(img):
    """Otsu's automatic thresholding"""
    print("Otsu's Threshold: Automatically finds optimal threshold to separate foreground/background")
    h, w = img.shape
    
    # Calculate histogram
    hist = np.zeros(256, dtype=int)
    for i in range(h):
        for j in range(w):
            hist[img[i, j]] += 1
    
    total_pixels = h * w
    best_thresh = 0
    max_variance = 0
    
    # Try all possible thresholds
    for t in range(256):
        # Background
        w0 = sum(hist[:t+1])
        if w0 == 0:
            continue
        
        # Foreground
        w1 = total_pixels - w0
        if w1 == 0:
            break
            
        # Mean intensities
        sum0 = sum(i * hist[i] for i in range(t+1))
        sum1 = sum(i * hist[i] for i in range(t+1, 256))
        
        mu0 = sum0 / w0 if w0 > 0 else 0
        mu1 = sum1 / w1 if w1 > 0 else 0
        
        # Between-class variance
        variance = w0 * w1 * (mu0 - mu1) ** 2
        
        if variance > max_variance:
            max_variance = variance
            best_thresh = t
    
    print(f"Otsu's optimal threshold: {best_thresh}")
    return binary_threshold(img, best_thresh), best_thresh

def multiple_threshold(img, thresholds=[85, 170]):
    """Multiple thresholding with multiple levels"""
    print(f"Multiple Threshold: Creates {len(thresholds)+1} intensity levels using thresholds {thresholds}")
    result = np.zeros_like(img)
    h, w = img.shape
    
    for i in range(h):
        for j in range(w):
            pixel = img[i, j]
            level = 0
            for thresh in thresholds:
                if pixel > thresh:
                    level += 1
            # Map levels to intensities
            result[i, j] = (level * 255) // len(thresholds)
    
    return result

# -------- Zoom Operations --------
def zero_order_hold_zoom(img, zoom_factor):
    """Zero-order hold (nearest neighbor) zooming"""
    print(f"Zero-Order Hold Zoom: Enlarges image by {zoom_factor}x using nearest neighbor (blocky)")
    h, w = img.shape
    new_h, new_w = int(h * zoom_factor), int(w * zoom_factor)
    result = np.zeros((new_h, new_w), dtype=np.uint8)
    
    for i in range(new_h):
        for j in range(new_w):
            orig_i = int(i / zoom_factor)
            orig_j = int(j / zoom_factor)
            if orig_i < h and orig_j < w:
                result[i, j] = img[orig_i, orig_j]
    
    return result

def first_order_hold_zoom(img, zoom_factor):
    """First-order hold (bilinear interpolation) zooming"""
    print(f"First-Order Hold Zoom: Enlarges image by {zoom_factor}x using bilinear interpolation (smooth)")
    h, w = img.shape
    new_h, new_w = int(h * zoom_factor), int(w * zoom_factor)
    result = np.zeros((new_h, new_w), dtype=np.uint8)
    
    for i in range(new_h):
        for j in range(new_w):
            # Map to original coordinates
            orig_i = i / zoom_factor
            orig_j = j / zoom_factor
            
            # Get integer parts
            i1, j1 = int(orig_i), int(orig_j)
            i2, j2 = min(i1 + 1, h - 1), min(j1 + 1, w - 1)
            
            # Get fractional parts
            di, dj = orig_i - i1, orig_j - j1
            
            # Bilinear interpolation
            if i1 < h and j1 < w:
                top_left = img[i1, j1]
                top_right = img[i1, j2]
                bottom_left = img[i2, j1]
                bottom_right = img[i2, j2]
                
                top = top_left * (1 - dj) + top_right * dj
                bottom = bottom_left * (1 - dj) + bottom_right * dj
                result[i, j] = int(top * (1 - di) + bottom * di)
    
    return result

# -------- Basic Image Operations --------
def crop_image(img, x1, y1, x2, y2):
    """Crop image to specified rectangle"""
    print(f"Crop: Extracts rectangular region from ({x1},{y1}) to ({x2},{y2})")
    return img[y1:y2, x1:x2]

def translate_image(img, tx, ty):
    """Translate image by tx, ty pixels"""
    print(f"Translation: Moves image by ({tx},{ty}) pixels")
    h, w = img.shape
    result = np.zeros_like(img)
    
    for i in range(h):
        for j in range(w):
            new_i, new_j = i + ty, j + tx
            if 0 <= new_i < h and 0 <= new_j < w:
                result[new_i, new_j] = img[i, j]
    
    return result

def rotate_image(img, angle_degrees):
    """Rotate image by specified angle (degrees)"""
    print(f"Rotation: Rotates image by {angle_degrees} degrees around center")
    h, w = img.shape
    result = np.zeros_like(img)
    
    # Convert to radians
    angle = math.radians(angle_degrees)
    cos_a, sin_a = math.cos(angle), math.sin(angle)
    
    # Center of image
    cx, cy = w // 2, h // 2
    
    for i in range(h):
        for j in range(w):
            # Translate to origin
            x, y = j - cx, i - cy
            
            # Apply rotation
            new_x = x * cos_a - y * sin_a
            new_y = x * sin_a + y * cos_a
            
            # Translate back
            orig_j = int(new_x + cx)
            orig_i = int(new_y + cy)
            
            if 0 <= orig_i < h and 0 <= orig_j < w:
                result[i, j] = img[orig_i, orig_j]
    
    return result

def flip_horizontal(img):
    """Flip image horizontally"""
    print("Horizontal Flip: Mirrors image left-to-right")
    h, w = img.shape
    result = np.zeros_like(img)
    
    for i in range(h):
        for j in range(w):
            result[i, j] = img[i, w - 1 - j]
    
    return result

def flip_vertical(img):
    """Flip image vertically"""
    print("Vertical Flip: Mirrors image top-to-bottom")
    h, w = img.shape
    result = np.zeros_like(img)
    
    for i in range(h):
        for j in range(w):
            result[i, j] = img[h - 1 - i, j]
    
    return result

# -------- Connected Component Labeling --------
def connected_component_labeling(binary_img):
    h, w = binary_img.shape
    labels = np.zeros((h, w), dtype=int)
    label = 1
    eq_table = {}   # store equivalences

    # ---- First Pass ----
    for i in range(h):
        for j in range(w):
            if binary_img[i, j] == 0:  # background
                continue

            top = labels[i-1, j] if i > 0 else 0
            left = labels[i, j-1] if j > 0 else 0

            if top == 0 and left == 0:          # Case 1: new label
                labels[i, j] = label
                eq_table[label] = label
                label += 1
            elif top != 0 and left == 0:        # Case 2: copy top
                labels[i, j] = top
            elif top == 0 and left != 0:        # Case 2: copy left
                labels[i, j] = left
            else:                               # Case 3: conflict
                labels[i, j] = min(top, left)
                if top != left:
                    # record equivalence
                    eq_table[max(top, left)] = min(top, left)

    # ---- Second Pass ----
    for i in range(h):
        for j in range(w):
            if labels[i, j] > 0:
                while labels[i, j] != eq_table[labels[i, j]]:
                    labels[i, j] = eq_table[labels[i, j]]
    return labels, eq_table

# -------- Edge Detection --------
def sobel_edge_detection(img, thresh=100):
    h, w = img.shape

    # Step 1: Define Sobel Kernels
    Kx = np.array([[-1,0,1],
                   [-2,0,2],
                   [-1,0,1]])
    Ky = np.array([[-1,-2,-1],
                   [0,0,0],
                   [1,2,1]])

    # Step 2: Convolve image with Sobel kernels (manual)
    Gx = np.zeros_like(img, dtype=int)
    Gy = np.zeros_like(img, dtype=int)

    for i in range(1, h-1):
        for j in range(1, w-1):
            region = img[i-1:i+2, j-1:j+2]
            Gx[i,j] = np.sum(region * Kx)
            Gy[i,j] = np.sum(region * Ky)

    # Step 3: Gradient magnitude
    G = np.sqrt(Gx**2 + Gy**2).astype(np.uint8)

    # Step 4: Simple Thresholding to detect edges
    edges = np.zeros_like(img, dtype=np.uint8)
    for i in range(h):
        for j in range(w):
            if G[i,j] > thresh:
                edges[i,j] = 255
            else:
                edges[i,j] = 0

    return edges, Gx, Gy, G

# -------- Histogram Equalization --------
def histogram_equalization(img):
    h, w = img.shape
    total_pixels = h * w
    L = 256  # gray levels

    # Step 1: Histogram (frequency of each intensity)
    hist = np.zeros(L, dtype=int)
    for i in range(h):
        for j in range(w):
            hist[img[i, j]] += 1

    # Step 2: CDF (cumulative frequency)
    cdf = np.zeros(L, dtype=int)
    cdf[0] = hist[0]
    for k in range(1, L):
        cdf[k] = cdf[k-1] + hist[k]

    # Step 3: Normalized CDF (using formula with L-1 and cdf_min)
    cdf_min = next(x for x in cdf if x > 0)
    new_values = np.zeros(L, dtype=int)
    for k in range(L):
        new_values[k] = round(((cdf[k] - cdf_min) / (total_pixels - cdf_min)) * (L-1))

    # Step 4: Map pixels
    out = np.zeros_like(img)
    for i in range(h):
        for j in range(w):
            out[i, j] = new_values[img[i, j]]

    return out, hist, cdf, new_values

# ----------- Example Usage -----------
if __name__ == "__main__":
    print("="*60)
    print("IMAGE PROCESSING OPERATIONS DEMONSTRATION")
    print("="*60)
    
    # Test with sample 4x4 image
    test_img = np.array([
        [52, 55, 61, 59],
        [79, 61, 76, 61],
        [85, 255, 90, 82],
        [59, 70, 85, 60]
    ], dtype=np.uint8)
    
    print("\nOriginal Test Image:")
    print(test_img)
    
    # -------- Gray Level Transformations --------
    print("\n" + "="*40)
    print("GRAY LEVEL TRANSFORMATIONS")
    print("="*40)
    
    linear_result = linear_transform(test_img, a=1.5, b=10)
    print("Linear Transform Result:")
    print(linear_result)
    
    log_result = log_transform(test_img, c=10)  # Reduced c value to prevent overflow
    print("\nLog Transform Result:")
    print(log_result)
    
    power_result = power_law_transform(test_img, c=1.0, gamma=0.5)
    print("\nPower Law Transform Result:")
    print(power_result)
    
    # -------- Thresholding --------
    print("\n" + "="*40)
    print("THRESHOLDING OPERATIONS")
    print("="*40)
    
    binary_result = binary_threshold(test_img, thresh=70)
    print("Binary Threshold Result:")
    print(binary_result)
    
    otsu_result, otsu_thresh = otsu_threshold(test_img)
    print(f"\nOtsu Threshold Result (threshold={otsu_thresh}):")
    print(otsu_result)
    
    multi_result = multiple_threshold(test_img, thresholds=[60, 80])
    print("\nMultiple Threshold Result:")
    print(multi_result)
    
    # -------- Zoom Operations --------
    print("\n" + "="*40)
    print("ZOOM OPERATIONS")
    print("="*40)
    
    zoom_zero = zero_order_hold_zoom(test_img, 2.0)
    print("Zero-Order Hold Zoom (2x):")
    print(zoom_zero)
    
    zoom_first = first_order_hold_zoom(test_img, 2.0)
    print("\nFirst-Order Hold Zoom (2x):")
    print(zoom_first)
    
    # -------- Basic Image Operations --------
    print("\n" + "="*40)
    print("BASIC IMAGE OPERATIONS")
    print("="*40)
    
    cropped = crop_image(test_img, 1, 1, 3, 3)
    print("Cropped Image (1,1) to (3,3):")
    print(cropped)
    
    translated = translate_image(test_img, 1, 1)
    print("\nTranslated Image (1,1):")
    print(translated)
    
    rotated = rotate_image(test_img, 90)
    print("\nRotated Image (90 degrees):")
    print(rotated)
    
    h_flipped = flip_horizontal(test_img)
    print("\nHorizontally Flipped:")
    print(h_flipped)
    
    v_flipped = flip_vertical(test_img)
    print("\nVertically Flipped:")
    print(v_flipped)
    
    # -------- Arithmetic Operations (if you have two images) --------
    print("\n" + "="*40)
    print("ARITHMETIC & LOGICAL OPERATIONS")
    print("="*40)
    
    # Create second test image
    test_img2 = np.array([
        [30, 40, 50, 60],
        [70, 80, 90, 100],
        [110, 120, 130, 140],
        [150, 160, 170, 180]
    ], dtype=np.uint8)
    
    print("Second Test Image:")
    print(test_img2)
    
    # Perform operations
    print("\n")
    and_result = img_and(test_img, test_img2)
    print("AND Result:")
    print(and_result)
    
    print("\n")
    or_result = img_or(test_img, test_img2)
    print("OR Result:")
    print(or_result)
    
    print("\n")
    xor_result = img_xor(test_img, test_img2)
    print("XOR Result:")
    print(xor_result)
    
    print("\n")
    add_result = img_add(test_img, test_img2)
    print("ADD Result:")
    print(add_result)
    
    print("\n")
    sub_result = img_sub(test_img, test_img2)
    print("SUBTRACT Result:")
    print(sub_result)
    
    print("\n")
    mul_result = img_mul(test_img, test_img2)
    print("MULTIPLY Result:")
    print(mul_result)
    
    print("\n")
    div_result = img_div(test_img, test_img2)
    print("DIVIDE Result:")
    print(div_result)
    
    # -------- Edge Detection --------
    print("\n" + "="*40)
    print("EDGE DETECTION")
    print("="*40)
    
    edges, Gx, Gy, G = sobel_edge_detection(test_img, thresh=100)
    print("Gradient X:")
    print(Gx)
    print("\nGradient Y:")
    print(Gy)
    print("\nGradient Magnitude:")
    print(G)
    print("\nEdges after thresholding:")
    print(edges)
    
    # -------- Histogram Equalization --------
    print("\n" + "="*40)
    print("HISTOGRAM EQUALIZATION")
    print("="*40)
    
    eq_img, hist, cdf, mapping = histogram_equalization(test_img)
    print("Histogram:")
    print(hist[:20])  # Show first 20 values
    print("\nCDF:")
    print(cdf[:20])   # Show first 20 values
    print("\nEqualized Image:")
    print(eq_img)
    
    print("\n" + "="*60)
    print("All operations completed successfully!")
    print("="*60)
    
    # Uncomment below to work with actual image files
    """
    # Load two images and convert to grayscale
    img1 = to_grayscale("path/to/your/image1.png")
    img2 = to_grayscale("path/to/your/image2.png")

    # Pad to same size
    img1, img2 = pad_images(img1, img2)
    
    # Perform operations and display results
    results = {
        "Original 1": img1,
        "Original 2": img2,
        "AND": img_and(img1, img2),
        "OR": img_or(img1, img2),
        "XOR": img_xor(img1, img2),
        "ADD": img_add(img1, img2),
        "SUB": img_sub(img1, img2),
        "MUL": img_mul(img1, img2),
        "DIV": img_div(img1, img2),
    }

    # Show results
    for k, v in results.items():
        plt.figure()
        plt.title(k)
        plt.imshow(v, cmap='gray')
        plt.axis("off")
        plt.show()
    """
