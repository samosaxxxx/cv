1 - Histogram Equilization
import numpy as np
import matplotlib.pyplot as plt
def histogram_equalization(img_array):
    # Step 1: Histogram (count of pixels per intensity 0–255)
    hist, bins = np.histogram(img_array.flatten(), bins=256, range=[0,256])
    # Step 2: Probability distribution
    prob = hist / hist.sum()
    # Step 3: CDF
    cdf = np.cumsum(prob)
    # Normalize CDF to [0, 255]
    cdf_normalized = (cdf * 255).astype(np.uint8)
    # Step 4: Map original intensities to equalized ones
    equalized_array = cdf_normalized[img_array]
    return equalized_array
# Example fixed input matrix (5x5 grayscale image)
img_matrix = np.array([
    [52, 55, 61, 59, 79],
    [62, 59, 55, 104, 94],
    [63, 65, 66, 113, 144],
    [64, 70, 70, 126, 154],
    [69, 73, 78, 128, 160]
], dtype=np.uint8)
equalized_array = histogram_equalization(img_matrix)
# Plot original and equalized histograms + images
plt.figure(figsize=(10,6))
plt.subplot(2,2,1)
plt.imshow(img_matrix, cmap="gray")
plt.title("Original Image")
plt.axis("off")
plt.subplot(2,2,2)
plt.imshow(equalized_array, cmap="gray")
plt.title("Equalized Image")
plt.axis("off")
plt.subplot(2,2,3)
plt.hist(img_matrix.flatten(), bins=256, range=[0,256], color="gray")
plt.title("Original Histogram")
plt.subplot(2,2,4)
plt.hist(equalized_array.flatten(), bins=256, range=[0,256], color="gray")
plt.title("Equalized Histogram")
plt.tight_layout()
plt.show()
print("Original Matrix:\n", img_matrix)
print("\nEqualized Matrix:\n", equalized_array)

2 - Transformation - Gray level modification
import numpy as np
import matplotlib.pyplot as plt
def gray_level_transformations(img_array):
    # 1. Negative transformation
    L = 256  # for 8-bit image
    negative = (L - 1) - img_array
    # 2. Log transformation
    c = 255 / np.log(1 + np.max(img_array))  # normalization factor
    log_transformed = c * np.log(1 + img_array)
    log_transformed = np.array(log_transformed, dtype=np.uint8)
    # 3. Power-law (Gamma) transformation
    gamma = 0.5  # try different values (0.5, 1.5, etc.)
    c = 255 / (np.max(img_array) ** gamma)
    gamma_transformed = c * (img_array ** gamma)
    gamma_transformed = np.array(gamma_transformed, dtype=np.uint8)
    return negative, log_transformed, gamma_transformed
# Example fixed grayscale matrix (5x5)
img_matrix = np.array([
    [10, 20, 30, 40, 50],
    [60, 70, 80, 90, 100],
    [110, 120, 130, 140, 150],
    [160, 170, 180, 190, 200],
    [210, 220, 230, 240, 250]
], dtype=np.uint8)
negative, log_transformed, gamma_transformed = gray_level_transformations(img_matrix)
# Plot results
plt.figure(figsize=(12,8))
plt.subplot(2,2,1)
plt.imshow(img_matrix, cmap="gray")
plt.title("Original Image")
plt.axis("off")
plt.subplot(2,2,2)
plt.imshow(negative, cmap="gray")
plt.title("Negative Transformation")
plt.axis("off")
plt.subplot(2,2,3)
plt.imshow(log_transformed, cmap="gray")
plt.title("Log Transformation")
plt.axis("off")
plt.subplot(2,2,4)
plt.imshow(gamma_transformed, cmap="gray")
plt.title("Gamma Transformation (γ=0.5)")
plt.axis("off")
plt.tight_layout()
plt.show()
print("Original Matrix:\n", img_matrix)
print("\nNegative Transformation:\n", negative)
print("\nLog Transformation:\n", log_transformed)
print("\nGamma Transformation (γ=0.5):\n", gamma_transformed)

3 - Region Splitting and Merging
import numpy as np
import matplotlib.pyplot as plt
# -----------------------------
# Function to check if region is homogeneous
# -----------------------------
def is_homogeneous(region, threshold):
    return (region.max() - region.min()) <= threshold
# -----------------------------
# Recursive function to split
# -----------------------------
def split(image, x, y, w, h, threshold):
    region = image[y:y+h, x:x+w]
    if w <= 1 or h <= 1 or is_homogeneous(region, threshold):
        return [(x, y, w, h)]
    w2, h2 = w // 2, h // 2
    regions = []
    regions += split(image, x, y, w2, h2, threshold)              # Top-left
    regions += split(image, x + w2, y, w - w2, h2, threshold)     # Top-right
    regions += split(image, x, y + h2, w2, h - h2, threshold)     # Bottom-left
    regions += split(image, x + w2, y + h2, w - w2, h - h2, threshold) # Bottom-right
    return regions
# -----------------------------
# Create segmented image from regions
# -----------------------------
def segment(image, regions):
    seg_img = np.zeros_like(image)
    for (x, y, w, h) in regions:
        mean_val = int(np.mean(image[y:y+h, x:x+w]))
        seg_img[y:y+h, x:x+w] = mean_val
    return seg_img
# Example fixed grayscale matrix (8x8)
img_matrix = np.array([
    [50, 52, 51, 53, 180, 182, 181, 183],
    [49, 50, 52, 54, 178, 179, 180, 182],
    [48, 50, 51, 52, 177, 178, 180, 181],
    [47, 49, 51, 53, 176, 178, 179, 180],
    [10, 12, 15, 14, 200, 202, 204, 206],
    [11, 13, 16, 15, 198, 200, 203, 205],
    [12, 14, 15, 17, 197, 199, 202, 204],
    [13, 15, 16, 18, 196, 198, 201, 203]
], dtype=np.uint8)
# Threshold for homogeneity
threshold = 10
# Split into regions
regions = split(img_matrix, 0, 0, img_matrix.shape[1], img_matrix.shape[0], threshold)
# Create segmented image
seg_img = segment(img_matrix, regions)
# Plot results
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.imshow(img_matrix, cmap="gray")
plt.title("Original Matrix Image")
plt.axis("off")
plt.subplot(1, 2, 2)
plt.imshow(seg_img, cmap="gray")
plt.title("Region Splitting & Merging")
plt.axis("off")
plt.show()
print("Original Matrix:\n", img_matrix)
print("\nSegmented Matrix:\n", seg_img)

4 - Edge Detection - Canny and other masks
import numpy as np
import math
#img = np.array([
#    [10, 9, 9, 4, 0],
#    [0, 6, 6, 2, 2],
#    [5, 9, 8, 4, 3],
#    [7, 5, 5, 4, 3],
#    [8, 10, 8, 5, 0]
#])
img = Image.open("/content/drive/MyDrive/MSc SS/9th Sem/20XW97 - CV lab/labwork/images.jpeg").convert("L")
img = np.array(img)
gaussian_kernel = np.array([
    [1, 2, 1],
    [2, 4, 2],
    [1, 2, 1]
]) / 16.0
x = np.array([
    [-1, 0, 1],
    [-2, 0, 2],
    [-1, 0, 1]
])
y = np.array([
    [1, 2, 1],
    [0, 0, 0],
    [-1, -2, -1]
])
height, width = img.shape
padded_image = np.pad(img, pad_width=1, mode='constant', constant_values=0)
filtered_img = np.zeros_like(img)
# Step 1: Apply Gaussian Filtering
for i in range(height):
    for j in range(width):
        region = padded_image[i:i+3, j:j+3]
        filtered_img[i, j] = np.sum(region * gaussian_kernel)
padded_filtered_image = np.pad(filtered_img, pad_width=1, mode='constant', constant_values=0)
gx = np.zeros((height, width))
gy = np.zeros((height, width))
magnitude = np.zeros((height, width))
angle = np.zeros((height, width))
#gx = np.zeros((height - 2, width - 2))
#gy = np.zeros((height - 2, width - 2))
#magnitude = np.zeros((height - 2, width - 2))
padded_height, padded_width = padded_filtered_image.shape
# Step 2: Calculate Gx, Gy using Sobel Operation
#for i in range(height - 2):
#  for j in range(width - 2):
    #region = img[i : i + 3, j : j + 3]
for i in range(padded_height - 2):
  for j in range(padded_width - 2):
    region = padded_filtered_image[i : i + 3, j : j + 3]
    gx[i][j] = np.sum(region * x)
    gy[i][j] = np.sum(region * y)
    # Step 3: Calculate Magnitude and Orientation matrix
    magnitude[i, j] = np.sqrt(gx[i][j] ** 2 + gy[i][j] ** 2)
    angle[i, j] = np.arctan2(gy[i, j], gx[i, j])
    angle[i, j] = np.where(angle[i, j] < 0, angle[i, j] + np.pi, angle[i, j])
    angle[i, j] = angle[i, j] * 180 / np.pi
min_val = np.min(magnitude)
max_val = np.max(magnitude)
magnitude = 255 * (magnitude - min_val) / (max_val - min_val)
edge_map = np.zeros_like(magnitude)
# Step 4: Apply Non-maximum Suppression
for i in range(1, height - 1):
  for j in range(1, width - 1):
    angle_deg = angle[i, j]
    mag = magnitude[i, j]
    if (0 <= angle_deg < 22.5) or (157.5 <= angle_deg <= 180 ):
        neighbors = [magnitude[i, j-1], magnitude[i, j+1]]
    elif (22.5 <= angle_deg < 67.5):
        neighbors = [magnitude[i-1, j+1], magnitude[i+1, j-1]]
    elif (67.5 <= angle_deg < 112.5):
        neighbors = [magnitude[i-1, j], magnitude[i+1, j]]
    else:
        neighbors = [magnitude[i-1, j-1], magnitude[i+1, j+1]]

    if mag >= max(neighbors):
        edge_map[i, j] = mag
    else:
        edge_map[i, j] = 0
# Step 5: Apply double thresholding
#avg_magnitude = np.mean(magnitude)
#high_threshold = avg_magnitude * 1.5
#low_threshold = avg_magnitude * 0.5
max_magnitude = np.max(magnitude)
high_threshold = max_magnitude * 0.8
low_threshold = max_magnitude * 0.25
strong_edges = (edge_map > high_threshold).astype(int)
weak_edges = ((edge_map > low_threshold) & (edge_map <= high_threshold)).astype(int)
# ------------------ Visualization ------------------
plt.figure(figsize=(12,10))
plt.subplot(2,3,1)
plt.imshow(img, cmap='gray')
plt.title("Original Image")
plt.axis("off")
plt.subplot(2,3,2)
plt.imshow(filtered_img, cmap='gray')
plt.title("Gaussian Filtered")
plt.axis("off")
plt.subplot(2,3,3)
plt.imshow(magnitude, cmap='gray')
plt.title("Gradient Magnitude")
plt.axis("off")
plt.subplot(2,3,4)
plt.imshow(angle, cmap='hsv')
plt.title("Gradient Orientation")
plt.axis("off")
plt.subplot(2,3,5)
plt.imshow(edge_map, cmap='gray')
plt.title("After Non-Max Suppression")
plt.axis("off")
plt.subplot(2,3,6)
plt.imshow(strong_edges + weak_edges, cmap='gray')
plt.title("Double Thresholding")
plt.axis("off")
plt.tight_layout()
plt.show()

5 - Binary Image Analysis - Connected components and labelling using or when matrix is given
import numpy as np
from PIL import Image
threshold = 128
binary_img = np.array([
    [0,0,1,0,0,1],
    [1,1,1,0,1,1],
    [0,1,0,0,0,0],
    [0,0,0,1,1,1],
    [0,0,0,1,0,1],
    [1,1,0,0,0,0],
  ])
binary_img = np.array([
    [1,1,1,0,0,0,0,0],
    [1,1,1,0,1,1,0,0],
    [1,1,1,0,1,1,0,0],
    [1,1,1,0,0,0,1,0],
    [1,1,1,0,0,0,1,0],
    [1,1,1,0,0,0,1,0],
    [1,1,1,0,0,0,1,0],
    [1,1,1,0,0,0,0,0],
  ])
binary_img = np.array([
    [0,0,0,0,0,0,0,0,0],
    [0,0,1,1,1,0,0,0,0],
    [0,0,1,1,0,1,1,0,0],
    [0,1,1,1,1,1,1,1,0],
    [0,1,1,1,0,1,1,0,0],
    [0,0,0,0,0,0,0,0,0]
  ])
print("\nOriginal Image")
print(binary_img)
height, width = binary_img.shape
labels = np.zeros((height, width), dtype=np.int32)
current_label = 0
equivalence_table = {}
# Pass 1
for x in range(height):
    for y in range(width):
        if binary_img[x][y] == 1:
            left_label, top_label = 0, 0
            if(x > 0):
                top_label = labels[x-1][y]
            if(y > 0):
                left_label = labels[x][y-1]
            if left_label != 0 and top_label != 0:
                if(left_label != top_label):
                    equivalence_table[max(left_label, top_label)] = equivalence_table[min(left_label, top_label)]
                labels[x][y] = min(left_label, top_label)
            elif left_label != 0 or top_label != 0:
                if left_label != 0:
                    labels[x][y] = left_label
                else:
                    labels[x][y] = top_label
            else:
                current_label += 1
                labels[x][y] = current_label
                equivalence_table[current_label] = current_label
print("First Pass: ")
print(labels)
# Pass 2
for i in range(height):
    for j in range(width):
        if labels[i, j] > 0:
            labels[i, j] = equivalence_table[labels[i, j]]
print("Second Pass: ")
print(labels)

6 - Arithmetic Logical operations
import numpy as np
import matplotlib.pyplot as plt
# Example grayscale matrices (5x5)
arr1 = np.array([
    [10, 50, 100, 150, 200],
    [20, 60, 110, 160, 210],
    [30, 70, 120, 170, 220],
    [40, 80, 130, 180, 230],
    [50, 90, 140, 190, 240]
], dtype=np.int16)
arr2 = np.array([
    [5, 25, 50, 100, 150],
    [15, 35, 75, 125, 175],
    [25, 45, 95, 145, 195],
    [35, 55, 105, 155, 205],
    [45, 65, 115, 165, 215]
], dtype=np.int16)
# Arithmetic Operations
add_img = np.clip(arr1 + arr2, 0, 255).astype(np.uint8)
sub_img = np.clip(arr1 - arr2, 0, 255).astype(np.uint8)
mul_img = np.clip(arr1 * arr2 / 255, 0, 255).astype(np.uint8)
div_img = np.clip(arr1 / (arr2 + 1) * 255, 0, 255).astype(np.uint8)  # avoid divide by zero
# Logical Operations
and_img = np.bitwise_and(arr1, arr2).astype(np.uint8)
or_img  = np.bitwise_or(arr1, arr2).astype(np.uint8)
xor_img = np.bitwise_xor(arr1, arr2).astype(np.uint8)
not_img1 = np.bitwise_not(arr1).astype(np.uint8)
# Display results using matplotlib
images = [arr1, arr2, add_img, sub_img, mul_img, div_img, and_img, or_img, xor_img, not_img1]
titles = ["Matrix 1", "Matrix 2", "Addition", "Subtraction", "Multiplication", "Division",
          "AND", "OR", "XOR", "NOT (Matrix1)"]
plt.figure(figsize=(12, 8))
for i in range(len(images)):
    plt.subplot(2, 5, i+1)
    plt.imshow(images[i], cmap="gray")
    plt.title(titles[i])
    plt.axis("off")
plt.tight_layout()
plt.show()
# Print matrices
print("Matrix 1:\n", arr1)
print("\nMatrix 2:\n", arr2)
print("\nAddition:\n", add_img)
print("\nSubtraction:\n", sub_img)
print("\nMultiplication:\n", mul_img)
print("\nDivision:\n", div_img)
print("\nAND:\n", and_img)
print("\nOR:\n", or_img)
print("\nXOR:\n", xor_img)
print("\nNOT (Matrix1):\n", not_img1)

8 - Thresholding - Otsu's
import numpy as np
# Example grayscale matrix
img = np.array([
    [0, 1, 2, 1, 0, 0],
    [0, 3, 4, 4, 1, 0],
    [2, 4, 5, 5, 4, 0],
    [1, 4, 5, 5, 4, 1],
    [0, 3, 4, 4, 3, 1],
    [0, 2, 3, 3, 2, 0]
])
# Step 1: Histogram (frequency of each intensity)
unique, counts = np.unique(img, return_counts=True)
freq = dict(zip(unique, counts))
intensity_levels = np.array(sorted(freq.keys()))      # sorted intensity values
counts_sorted = np.array([freq[i] for i in intensity_levels])  # sorted counts
intensity_count = len(intensity_levels)
pixel_count = img.size
# Step 2: Compute between-class variance for each possible threshold
sig_b = np.zeros(intensity_count)
for i in range(intensity_count):
    # Background (below threshold i)
    wb = np.sum(counts_sorted[:i]) / pixel_count
    # Foreground (above threshold i)
    wf = np.sum(counts_sorted[i:]) / pixel_count
    # Avoid division by zero
    if np.sum(counts_sorted[:i]) == 0:
        mb = 0
    else:
        mb = np.sum(intensity_levels[:i] * counts_sorted[:i]) / np.sum(counts_sorted[:i])
    if np.sum(counts_sorted[i:]) == 0:
        mf = 0
    else:
        mf = np.sum(intensity_levels[i:] * counts_sorted[i:]) / np.sum(counts_sorted[i:])
    # Between-class variance
    var_b = wb * wf * (mb - mf) ** 2
    sig_b[i] = var_b
# Step 3: Optimal threshold is the intensity that maximizes between-class variance
optimal_threshold_index = np.argmax(sig_b)
optimal_threshold = intensity_levels[optimal_threshold_index]
print("\nUnique intensities:", intensity_levels)
print("Frequency:", counts_sorted)
print("\nBetween-class variance for each threshold:")
print(sig_b)
print("\nOptimal Threshold (Otsu's Method):", optimal_threshold)
