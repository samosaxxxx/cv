1 - Histogram Equilization
from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
# Load image and convert to grayscale
img = Image.open("/content/drive/MyDrive/MSc SS/9th Sem/20XW97 - CV lab/labwork/images.jpeg").convert("L")
# Convert to numpy array
img_array = np.array(img)
# Step 1: Histogram (count of pixels per intensity 0–255)
hist, bins = np.histogram(img_array.flatten(), bins=256, range=[0,256])
# Step 2: Probability distribution
prob = hist / hist.sum()
# Step 3: CDF
cdf = np.cumsum(prob)
# Normalize CDF to [0, 255]
cdf_normalized = (cdf * 255).astype(np.uint8)
# Step 4: Map original intensities to equalized ones
equalized_array = cdf_normalized[img_array]
# Convert back to image
equalized_img = Image.fromarray(equalized_array)
# Plot original and equalized histograms
plt.figure(figsize=(12,6))
plt.subplot(2,2,1)
plt.imshow(img, cmap="gray")
plt.title("Original Image")
plt.axis("off")
plt.subplot(2,2,2)
plt.imshow(equalized_img, cmap="gray")
plt.title("Equalized Image")
plt.axis("off")
plt.subplot(2,2,3)
plt.hist(img_array.flatten(), bins=256, range=[0,256], color="gray")
plt.title("Original Histogram")
plt.subplot(2,2,4)
plt.hist(equalized_array.flatten(), bins=256, range=[0,256], color="gray")
plt.title("Equalized Histogram")
plt.tight_layout()
plt.show()

2 - Transformation - Gray level modification
from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
# Load and convert to grayscale
img = Image.open("/content/drive/MyDrive/MSc SS/9th Sem/20XW97 - CV lab/labwork/images.jpeg").convert("L")
img_array = np.array(img)
# 1. Negative transformation
L = 256  # for 8-bit image
negative = (L - 1) - img_array
# 2. Log transformation
c = 255 / np.log(1 + np.max(img_array))  # normalization factor
log_transformed = c * np.log(1 + img_array)
log_transformed = np.array(log_transformed, dtype=np.uint8)
# 3. Power-law (Gamma) transformation
gamma = 0.5  # try 0.5, 1.5 etc.
c = 255 / (np.max(img_array) ** gamma)
gamma_transformed = c * (img_array ** gamma)
gamma_transformed = np.array(gamma_transformed, dtype=np.uint8)
# Plot results
plt.figure(figsize=(12,8))
plt.subplot(2,2,1)
plt.imshow(img_array, cmap="gray")
plt.title("Original Image")
plt.axis("off")
plt.subplot(2,2,2)
plt.imshow(negative, cmap="gray")
plt.title("Negative Transformation")
plt.axis("off")
plt.subplot(2,2,3)
plt.imshow(log_transformed, cmap="gray")
plt.title("Log Transformation")
plt.axis("off")
plt.subplot(2,2,4)
plt.imshow(gamma_transformed, cmap="gray")
plt.title("Gamma Transformation (γ=0.5)")
plt.axis("off")
plt.tight_layout()
plt.show()

3 - Region Splitting and Merging
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

# -----------------------------
# Function to check if region is homogeneous
# -----------------------------
def is_homogeneous(region, threshold):
    return (region.max() - region.min()) <= threshold

# -----------------------------
# Recursive function to split
# -----------------------------
def split(image, x, y, w, h, threshold):
    region = image[y:y+h, x:x+w]

    if w <= 1 or h <= 1 or is_homogeneous(region, threshold):
        return [(x, y, w, h)]

    w2, h2 = w // 2, h // 2
    regions = []
    regions += split(image, x, y, w2, h2, threshold)           # Top-left
    regions += split(image, x + w2, y, w - w2, h2, threshold) # Top-right
    regions += split(image, x, y + h2, w2, h - h2, threshold) # Bottom-left
    regions += split(image, x + w2, y + h2, w - w2, h - h2, threshold) # Bottom-right

    return regions

# -----------------------------
# Draw segmented image
# -----------------------------
def segment(image, regions):
    seg_img = np.zeros_like(image)
    for (x, y, w, h) in regions:
        mean_val = int(np.mean(image[y:y+h, x:x+w]))
        seg_img[y:y+h, x:x+w] = mean_val
    return seg_img

# -----------------------------
# Merge function (replace segment)
# -----------------------------
def merge(image, regions, threshold):
    merged_img = np.zeros_like(image)

    # Initially treat each region as separate
    visited = [False] * len(regions)

    for i in range(len(regions)):
        if visited[i]:
            continue

        (x1, y1, w1, h1) = regions[i]
        region1 = image[y1:y1+h1, x1:x1+w1]
        group = [(x1, y1, w1, h1)]
        visited[i] = True

        for j in range(i+1, len(regions)):
            if visited[j]:
                continue

            (x2, y2, w2, h2) = regions[j]
            region2 = image[y2:y2+h2, x2:x2+w2]

            cond1 = (region1.max() - region2.min()) <= threshold
            cond2 = (region2.max() - region1.min()) <= threshold

            if cond1 and cond2:
                group.append((x2, y2, w2, h2))
                visited[j] = True

        # Assign mean value of merged group
        all_pixels = []
        for (x, y, w, h) in group:
            all_pixels.append(image[y:y+h, x:x+w].flatten())
        all_pixels = np.concatenate(all_pixels)
        mean_val = int(np.mean(all_pixels))

        for (x, y, w, h) in group:
            merged_img[y:y+h, x:x+w] = mean_val

    return merged_img

# -----------------------------
# Load image (grayscale)
# -----------------------------
img = Image.open("/content/drive/MyDrive/MSc SS/9th Sem/20XW97 - CV lab/labwork/images.jpeg").convert("L")
img_np = np.array(img)

# Threshold
threshold = 100

# Split into regions
regions = split(img_np, 0, 0, img_np.shape[1], img_np.shape[0], threshold)

# Merge regions
merged_img = merge(img_np, regions, threshold)

# Create segmented image
# seg_img = segment(img_np, regions)

# -----------------------------
# Plot results
# -----------------------------
plt.figure(figsize=(12, 6))

plt.subplot(1, 2, 1)
plt.imshow(img_np, cmap="gray")
plt.title("Original Image")
plt.axis("off")

plt.subplot(1, 2, 2)
plt.imshow(merged_img, cmap="gray")
plt.title("Region Splitting & Merging")
plt.axis("off")

plt.show()


4 - Edge Detection - Canny and other masks
import numpy as np
import math
#img = np.array([
#    [10, 9, 9, 4, 0],
#    [0, 6, 6, 2, 2],
#    [5, 9, 8, 4, 3],
#    [7, 5, 5, 4, 3],
#    [8, 10, 8, 5, 0]
#])
img = Image.open("/content/drive/MyDrive/MSc SS/9th Sem/20XW97 - CV lab/labwork/images.jpeg").convert("L")
img = np.array(img)
gaussian_kernel = np.array([
    [1, 2, 1],
    [2, 4, 2],
    [1, 2, 1]
]) / 16.0
x = np.array([
    [-1, 0, 1],
    [-2, 0, 2],
    [-1, 0, 1]
])
y = np.array([
    [1, 2, 1],
    [0, 0, 0],
    [-1, -2, -1]
])
height, width = img.shape
padded_image = np.pad(img, pad_width=1, mode='constant', constant_values=0)
filtered_img = np.zeros_like(img)
# Step 1: Apply Gaussian Filtering
for i in range(height):
    for j in range(width):
        region = padded_image[i:i+3, j:j+3]
        filtered_img[i, j] = np.sum(region * gaussian_kernel)
padded_filtered_image = np.pad(filtered_img, pad_width=1, mode='constant', constant_values=0)
gx = np.zeros((height, width))
gy = np.zeros((height, width))
magnitude = np.zeros((height, width))
angle = np.zeros((height, width))
#gx = np.zeros((height - 2, width - 2))
#gy = np.zeros((height - 2, width - 2))
#magnitude = np.zeros((height - 2, width - 2))
padded_height, padded_width = padded_filtered_image.shape
# Step 2: Calculate Gx, Gy using Sobel Operation
#for i in range(height - 2):
#  for j in range(width - 2):
    #region = img[i : i + 3, j : j + 3]
for i in range(padded_height - 2):
  for j in range(padded_width - 2):
    region = padded_filtered_image[i : i + 3, j : j + 3]
    gx[i][j] = np.sum(region * x)
    gy[i][j] = np.sum(region * y)
    # Step 3: Calculate Magnitude and Orientation matrix
    magnitude[i, j] = np.sqrt(gx[i][j] ** 2 + gy[i][j] ** 2)
    angle[i, j] = np.arctan2(gy[i, j], gx[i, j])
    angle[i, j] = np.where(angle[i, j] < 0, angle[i, j] + np.pi, angle[i, j])
    angle[i, j] = angle[i, j] * 180 / np.pi
min_val = np.min(magnitude)
max_val = np.max(magnitude)
magnitude = 255 * (magnitude - min_val) / (max_val - min_val)
edge_map = np.zeros_like(magnitude)
# Step 4: Apply Non-maximum Suppression
for i in range(1, height - 1):
  for j in range(1, width - 1):
    angle_deg = angle[i, j]
    mag = magnitude[i, j]
    if (0 <= angle_deg < 22.5) or (157.5 <= angle_deg <= 180 ):
        neighbors = [magnitude[i, j-1], magnitude[i, j+1]]
    elif (22.5 <= angle_deg < 67.5):
        neighbors = [magnitude[i-1, j+1], magnitude[i+1, j-1]]
    elif (67.5 <= angle_deg < 112.5):
        neighbors = [magnitude[i-1, j], magnitude[i+1, j]]
    else:
        neighbors = [magnitude[i-1, j-1], magnitude[i+1, j+1]]

    if mag >= max(neighbors):
        edge_map[i, j] = mag
    else:
        edge_map[i, j] = 0
# Step 5: Apply double thresholding
#avg_magnitude = np.mean(magnitude)
#high_threshold = avg_magnitude * 1.5
#low_threshold = avg_magnitude * 0.5
max_magnitude = np.max(magnitude)
high_threshold = max_magnitude * 0.8
low_threshold = max_magnitude * 0.25
strong_edges = (edge_map > high_threshold).astype(int)
weak_edges = ((edge_map > low_threshold) & (edge_map <= high_threshold)).astype(int)
# ------------------ Visualization ------------------
plt.figure(figsize=(12,10))
plt.subplot(2,3,1)
plt.imshow(img, cmap='gray')
plt.title("Original Image")
plt.axis("off")
plt.subplot(2,3,2)
plt.imshow(filtered_img, cmap='gray')
plt.title("Gaussian Filtered")
plt.axis("off")
plt.subplot(2,3,3)
plt.imshow(magnitude, cmap='gray')
plt.title("Gradient Magnitude")
plt.axis("off")
plt.subplot(2,3,4)
plt.imshow(angle, cmap='hsv')
plt.title("Gradient Orientation")
plt.axis("off")
plt.subplot(2,3,5)
plt.imshow(edge_map, cmap='gray')
plt.title("After Non-Max Suppression")
plt.axis("off")
plt.subplot(2,3,6)
plt.imshow(strong_edges + weak_edges, cmap='gray')
plt.title("Double Thresholding")
plt.axis("off")
plt.tight_layout()
plt.show()

5 - Binary Image Analysis - Connected components and labelling using or when matrix is given
import numpy as np
from PIL import Image
threshold = 128
binary_img = np.array([
    [0,0,1,0,0,1],
    [1,1,1,0,1,1],
    [0,1,0,0,0,0],
    [0,0,0,1,1,1],
    [0,0,0,1,0,1],
    [1,1,0,0,0,0],
  ])
binary_img = np.array([
    [1,1,1,0,0,0,0,0],
    [1,1,1,0,1,1,0,0],
    [1,1,1,0,1,1,0,0],
    [1,1,1,0,0,0,1,0],
    [1,1,1,0,0,0,1,0],
    [1,1,1,0,0,0,1,0],
    [1,1,1,0,0,0,1,0],
    [1,1,1,0,0,0,0,0],
  ])
binary_img = np.array([
    [0,0,0,0,0,0,0,0,0],
    [0,0,1,1,1,0,0,0,0],
    [0,0,1,1,0,1,1,0,0],
    [0,1,1,1,1,1,1,1,0],
    [0,1,1,1,0,1,1,0,0],
    [0,0,0,0,0,0,0,0,0]
  ])
print("\nOriginal Image")
print(binary_img)
height, width = binary_img.shape
labels = np.zeros((height, width), dtype=np.int32)
current_label = 0
equivalence_table = {}
# Pass 1
for x in range(height):
    for y in range(width):
        if binary_img[x][y] == 1:
            left_label, top_label = 0, 0
            if(x > 0):
                top_label = labels[x-1][y]
            if(y > 0):
                left_label = labels[x][y-1]
            if left_label != 0 and top_label != 0:
                if(left_label != top_label):
                    equivalence_table[max(left_label, top_label)] = equivalence_table[min(left_label, top_label)]
                labels[x][y] = min(left_label, top_label)
            elif left_label != 0 or top_label != 0:
                if left_label != 0:
                    labels[x][y] = left_label
                else:
                    labels[x][y] = top_label
            else:
                current_label += 1
                labels[x][y] = current_label
                equivalence_table[current_label] = current_label
print("First Pass: ")
print(labels)
# Pass 2
for i in range(height):
    for j in range(width):
        if labels[i, j] > 0:
            labels[i, j] = equivalence_table[labels[i, j]]
print("Second Pass: ")
print(labels)

5 - Binary Image Analysis - Connected components and labelling using or when image is given
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
# Load image
img = Image.open("/content/drive/MyDrive/MSc SS/9th Sem/20XW97 - CV lab/labwork/images.jpeg").convert("L")
img_array = np.array(img)
# Thresholding to binary (0 or 1)
threshold = 128
binary_img = (img_array > threshold).astype(np.int32)
height, width = binary_img.shape
labels = np.zeros((height, width), dtype=np.int32)
current_label = 0
equivalence_table = {}
# Pass 1
for x in range(height):
    for y in range(width):
        if binary_img[x][y] == 1:
            left_label, top_label = 0, 0
            if x > 0:
                top_label = labels[x-1][y]
            if y > 0:
                left_label = labels[x][y-1]
            if left_label != 0 and top_label != 0:
                labels[x][y] = min(left_label, top_label)
                if left_label != top_label:
                    equivalence_table[max(left_label, top_label)] = equivalence_table[min(left_label, top_label)]
            elif left_label != 0 or top_label != 0:
                labels[x][y] = left_label if left_label != 0 else top_label
            else:
                current_label += 1
                labels[x][y] = current_label
                equivalence_table[current_label] = current_label
# Pass 2: resolve equivalences
for i in range(height):
    for j in range(width):
        if labels[i, j] > 0:
            labels[i, j] = equivalence_table[labels[i, j]]
# Normalize labels for visualization
unique_labels = np.unique(labels)
label_map = {label: idx for idx, label in enumerate(unique_labels)}
colored_labels = np.vectorize(label_map.get)(labels)
# ---------------- Visualization ----------------
plt.figure(figsize=(12,5))
plt.subplot(1,2,1)
plt.imshow(binary_img, cmap="gray")
plt.title("Binary Input Image")
plt.axis("off")
plt.subplot(1,2,2)
plt.imshow(colored_labels, cmap="tab20")
plt.title("Connected Components")
plt.axis("off")
plt.show()

6 - Arithmetic Logical operations
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
# Load two images (convert to grayscale for simplicity)
img1 = Image.open("/content/drive/MyDrive/MSc SS/9th Sem/20XW97 - CV lab/labwork/images.jpeg").convert("L")
img2 = Image.open("/content/drive/MyDrive/MSc SS/9th Sem/20XW97 - CV lab/labwork/images2.jpeg").convert("L")
img2 = img2.resize(img1.size)
# Convert to NumPy arrays
arr1 = np.array(img1, dtype=np.int16)  # use int16 to avoid overflow during operations
arr2 = np.array(img2, dtype=np.int16)
# Arithmetic Operations
add_img = np.clip(arr1 + arr2, 0, 255).astype(np.uint8)
sub_img = np.clip(arr1 - arr2, 0, 255).astype(np.uint8)
mul_img = np.clip(arr1 * arr2 / 255, 0, 255).astype(np.uint8)
div_img = np.clip(arr1 / (arr2 + 1) * 255, 0, 255).astype(np.uint8)  # avoid divide by zero
# Logical Operations
and_img = np.bitwise_and(arr1, arr2).astype(np.uint8)
or_img  = np.bitwise_or(arr1, arr2).astype(np.uint8)
xor_img = np.bitwise_xor(arr1, arr2).astype(np.uint8)
not_img1 = np.bitwise_not(arr1).astype(np.uint8)
# Display results using matplotlib
images = [img1, img2, add_img, sub_img, mul_img, div_img, and_img, or_img, xor_img, not_img1]
titles = ["Image 1", "Image 2", "Addition", "Subtraction", "Multiplication", "Division",
          "AND", "OR", "XOR", "NOT (Image1)"]
plt.figure(figsize=(12, 8))
for i in range(len(images)):
    plt.subplot(2, 5, i+1)
    plt.imshow(images[i], cmap="gray")
    plt.title(titles[i])
    plt.axis("off")
plt.tight_layout()
plt.show()

8 - Thresholding - Otsu's
import numpy as np
img = np.array([
    [0, 1, 2, 1, 0, 0],
    [0, 3, 4, 4, 1, 0],
    [2, 4, 5, 5, 4, 0],
    [1, 4, 5, 5, 4, 1],
    [0, 3, 4, 4, 3, 1],
    [0, 2, 3, 3, 2, 0]
])
freq = dict()
for i in range(img.shape[0]):
    for j in range(img.shape[1]):
        if img[i, j] in freq:
            freq[img[i, j]] += 1
        else:
            freq[img[i, j]] = 1
intensity_count = len(freq)
pixel_count = img.shape[0] * img.shape[1]
sig_b = np.zeros(intensity_count)
for i in range(len(freq)):
  wb = np.sum(list(freq.values())[:i]) / pixel_count
  wf = np.sum(list(freq.values())[i:]) / pixel_count
  if i == 0:
    mb = 0
    mf = 1
  else:
    mb = np.sum(np.array(list(freq.keys()))[:i] * np.array(list(freq.values()))[:i]) / np.sum(list(freq.values())[:i])
    mf = np.sum(np.array(list(freq.keys()))[i:] * np.array(list(freq.values()))[i:]) / np.sum(list(freq.values())[i:])
  var_b = wb * wf * (mb - mf) ** 2
  sig_b[i] = var_b
# Find the optimal threshold
optimal_threshold_index = np.argmax(sig_b)
print("\nBetween-class variance for each threshold:")
print(sig_b)
print("\nOptimal Threshold (Otsu's Method):")
print(optimal_threshold_index)

10 - Basic Image Operations
from PIL import Image
import matplotlib.pyplot as plt
import numpy as np
img = Image.open('/content/drive/MyDrive/MSc SS/9th Sem/20XW97 - CV lab/labwork/images.jpeg')
print(img.height,img.width,img.mode,img.format,type(img))
plt.axis('off')
plt.imshow(img)
plt.show()
#this helps in changing the color image into gray image
graying=img.convert('L')
#this function is used to change the pixel values
newimg=img.point(lambda i:i*20)
print("After applying lambda function (Multiply by 20)")
plt.imshow(newimg)
plt.show()
#load the image ,split the image into channels ,modify the red component by point functions by 20 point,
#merge the three channels,display the image
print("Individual channels (R, G, B)")
red, green, blue= img.split()
print("Red")
plt.imshow(red)
plt.show()
print("Green")
plt.imshow(green)
plt.show()
print("Blue")
plt.imshow(blue)
plt.show()
print("Modified Red channel")
new_red=red.point(lambda i:i+20)
plt.imshow(new_red)
plt.show()
print("Modified Image")
modified_img = Image.merge('RGB', (new_red, green, blue))
plt.imshow(modified_img)
plt.show()
#rotation of the image
print("Rotated Image")
rotated_image = img.rotate(45)
plt.imshow(rotated_image)
plt.show()
#translation of the image
tx = 50  # Horizontal translation (pixels)
ty = -20 # Vertical translation (pixels)
transform_matrix = (1, 0, tx, 0, 1, ty)
translated_img = img.transform(img.size, Image.AFFINE, transform_matrix)
print("Translated Image (50, -20)")
plt.imshow(translated_img)
plt.show()
#Resize the image
new_width = 300
new_height = 200
resized_image = img.resize((new_width, new_height))
print("Resized Image (300, 200)")
plt.imshow(resized_image)
plt.show()
#Flip the image
# Horizontal flip
flipped_left_right = img.transpose(Image.FLIP_LEFT_RIGHT)
# Vertical flip
flipped_top_bottom = img.transpose(Image.FLIP_TOP_BOTTOM)
print("Flipped Image")
print("Horizontal Flip")
plt.imshow(flipped_left_right)
plt.show()
print("Vertical Flip")
plt.imshow(flipped_top_bottom)
plt.show()
#Crop the image
left = 0
top = 0
right = 100
bottom = 100
box = (left, top, right, bottom)
cropped_img = img.crop(box)
print("Cropped Image (0, 0) (100, 100)")
plt.imshow(cropped_img)
plt.show()
# Determine dimensions for horizontal concatenation (example)
combined_width = img.width + flipped_left_right.width
max_height = max(img.height, flipped_left_right.height)
# Create a new blank image
combined_image = Image.new("RGB", (combined_width, max_height))
# Paste images
combined_image.paste(img, (0, 0))  # Paste image1 at top-left
combined_image.paste(flipped_left_right, (img.width, 0)) # Paste image2 next to image1
print("Combined Image")
plt.imshow(combined_image)
plt.show()


